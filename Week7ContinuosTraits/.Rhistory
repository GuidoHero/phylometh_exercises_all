one.discrete.char <
library(ape) #utility fns
library(geiger) #utilty fns
library(OUwie)
library(fishtree)
library(dplyr)
library(tidyr)
continuous.data <- read.csv("D:/OneDrive - Pontificia Universidad Javeriana/Documents/NutritionalValuesFishes/Nutrients_EntireDataSet.csv")
tree <- fishtree_phylogeny(type="chronogram")
CleanData <- function(data, phylo) {
data$Species <- gsub(' ', '_' , continuous.data$Species)
data <- data %>%
group_by(Species) %>%
summarize(mean_Pr = mean(Pr)) %>%
drop_na()  %>%
filter(Species %in% phylo$tip.label)
trait <- as.numeric(data$mean_Pr)
names(trait) <- data$Species
datatree <- treedata(tree, trait)
return(datatree)
}
data <- CleanData(continuous.data, tree)
VisualizeData <- function(phy, data) {
phytools::contMap(phy, data)
}
#### This is how is fitted here
BM1
BM1 <- geiger::fitContinuous(data$phy, data$data, model="BM")
print(paste("The rate of evolution is", BM1$opt$sigsq, "in units of", "time"))
OU1 <- fitContinuous(data$phy, data$data, model="OU")
par(mfcol(c(1,2)))
plot(tree, show.tip.label=FALSE)
ou.tree <- rescale(tree, model="OU", OU1$opt$alpha)
plot(ou.tree)
AIC.BM1 <- AIC(BM1)
AIC.OU1 <- AIC(OU1)
delta.AIC.BM1 <- AIC.BM1 - min(AIC.BM1, AIC.OU1)
delta.AIC.OU1 <- AIC.OU1 - min(AIC.BM1, AIC.OU1)
##OUwie runs##
one.discrete.char <- as.numeric(data$data < mean(data$data))
one.discrete.char
labeled.tree <- data$phy
labeled.tree <- data$phy
nodeBased.OUMV <- OUwie(labeled.tree, data$data, model="OUMV", simmap.tree=FALSE, diagn=FALSE)
nodeBased.OUMV <- OUwie(data$tree, data$data, model="OUMV", simmap.tree=FALSE, diagn=FALSE)
OU1 <- fitContinuous(data$phy, data$data, model="OU")
par(mfcol(c(1,2)))
plot(tree, show.tip.label=FALSE)
ou.tree <- rescale(tree, model="OU", OU1$opt$alpha)
plot(ou.tree)
best.states
best.states
one.discrete.char <- as.numeric(data$data < mean(data$data))
reconstruction.info <- ace(one.discrete.char, data$phy, type="discrete", method="ML", CI=TRUE)
best.states <- colnames(reconstruction.info$lik.anc)[apply(reconstruction.info$lik.anc, 1, which.max)]
best.states
one.discrete.char
library(fishtree);
library(caper);
library(geiger);
library(phytools);
library(diversitree);
library(phangorn);
library(corHMM);
library(tidyverse)
tree <- fishtree_phylogeny(type = "chronogram")
discrete.data <- read.csv("D:/OneDrive - Pontificia Universidad Javeriana/Documents/MigrationAmazon/Analysis/MigratoryStatusAll.csv", stringsAsFactors=FALSE) #death to factors.
CleanData <- function(phy, data) {
colnames(data) <- c("Species","MigratoryTrait")
trait <- as.numeric(data$MigratoryTrait)
names(trait) <- data$Species
datatree <- treedata(phy, trait)
return(datatree)
}
data.clean <- CleanData(tree, discrete.data)
data <- data.clean$data
phy <- data.clean$phy
VisualizeData <- function(phy, data) {
plotTree(phy,type="fan", fsize=0.0001, ftype="i")
cols <- setNames(c("#b2182b", "#2166ac"), c("0", "1"))
tiplabels(pie=as.matrix(data)[,1], piecol=cols,cex=0.2)
legend("topleft",levels(data),pch=21,pt.bg= cols , pt.cex=2.2)
}
VisualizeData(data.clean$phy, data.clean$data)
cleaned.discrete.phyDat <- phangorn::phyDat(data.clean$data, type="USER",levels=c(0,1))
anc.p <- phangorn::ancestral.pars(data.clean$phy, cleaned.discrete.phyDat)
plotAnc(data.clean$phy, anc.p, 1, cex=0.1, cex.pie =0.3, type="fan")
anc.ml <- ancestral.pml(pml(data.clean$phy, cleaned.discrete.phyDat), type="ml")
plotAnc(data.clean$phy, anc.ml, 1, cex=0.1, size=0.0001, cex.pie =0.3, type="fan")
############## BIOLOGICAL QUESTIONS #########################
#How does this differ from parsimony?#
# Parsimony provide absolute/discrete reconstruction of ancestral states, while maximum likelihood shows support
#in terms of probability represented in pie charts
##Why does it differ from parsimony?##
# Parsimony reconstruction deals with
##What does uncertainty mean?##
#Uncertainty is reflected as the degree of support for the reconstruction of each one of the nodes, which,
#is impacted from the limitation in reconstructions in more ancestral nodes. Uncertainty decreases as we go deeper in the tree.
############## BIOLOGICAL QUESTIONS #########################
##1. How can you estimate transition rates between states? Do it.##
clean.df <- function(data, trait.name){
data.df <- as.data.frame(data)
data.df$Species <- rownames(data.df)
rownames(data.df) <- NULL
colnames(data.df) <- c(trait.name,"Species")
data.df[,trait.name] <- as.factor(data.df[, trait.name])
data.df <- data.df[,c("Species", trait.name)]
return(data.df)
}
TransitionRates <- corHMM::corHMM(data.clean$phy, clean.df(data.clean$data, "Migration"), rate.cat = 1)
##2. How could you examine if transition rates are equal?##
print(TransitionRates$solution)
# Transition rates are not equal as there is a higher transition rate from  migratory (1) to non migratory (0),
# than non-migratory (0) to migratory (1)
# 3. Think about the Lewis (2001) MKV model. Are your traits all variable? Will using this make sense for your data? Try using it. Do results change?###
# Migratory trait is variable as it is present across multiple clades across the tree (no autapomorphies) and both states occur.
#For that reason, seems reasonable to use Lewis (2001) MKV model. However, I do not notice major differences visually with the previous approach.
anc.Mkv <- phangorn::ancestral.pml(pml(data.clean$phy, cleaned.discrete.phyDat, Mkv = TRUE), type="ml") #MKV through Maximum Likelihood
plotAnc(data.clean$phy, anc.Mkv, 1, cex=0.1, size=0.0001, cex.pie =0.3, type="fan")
plan <- drake_plan(
tree = generate_data(),
discrete.data <- read.csv("D:/OneDrive - Pontificia Universidad Javeriana/Documents/MigrationAmazon/Analysis/MigratoryStatusAll.csv", stringsAsFactors=FALSE),
VisualizeData(data.clean$phy, data.clean$data),
cleaned.discrete.phyDat <- phangorn::phyDat(data.clean$data, type="USER",levels=c(0,1)),
anc.p <- phangorn::ancestral.pars(data.clean$phy, cleaned.discrete.phyDat),
plotAnc(data.clean$phy, anc.p, 1, cex=0.1, cex.pie =0.3, type="fan"),
anc.ml <- ancestral.pml(pml(data.clean$phy, cleaned.discrete.phyDat), type="ml"),
plotAnc(data.clean$phy, anc.ml, 1, cex=0.1, size=0.0001, cex.pie =0.3, type="fan"),
TransitionRates <- corHMM::corHMM(data.clean$phy, clean.df(data.clean$data, "Migration"), rate.cat = 1),
anc.Mkv <- phangorn::ancestral.pml(pml(data.clean$phy, cleaned.discrete.phyDat, Mkv = TRUE), type="ml"), #MKV through Maximum Likelihood
plotAnc(data.clean$phy, anc.Mkv, 1, cex=0.1, size=0.0001, cex.pie =0.3, type="fan"),
)
CleanData <- function(data, phylo) {
data$Species <- gsub(' ', '_' , continuous.data$Species)
data <- data %>%
group_by(Species) %>%
summarize(mean_Pr = mean(Pr)) %>%
drop_na()  %>%
filter(Species %in% phylo$tip.label)
trait <- as.numeric(data$mean_Pr)
names(trait) <- data$Species
datatree <- treedata(tree, trait)
return(datatree)
}
clean.df <- function(data, trait.name){
data.df <- as.data.frame(data)
data.df$Species <- rownames(data.df)
rownames(data.df) <- NULL
colnames(data.df) <- c(trait.name,"Species")
data.df[,trait.name] <- as.factor(data.df[, trait.name])
data.df <- data.df[,c("Species", trait.name)]
return(data.df)
}
VisualizeData<- function (tree, trait){
circplot <- ggtree(tree, layout = "circular")
cirplot.trait <- gheatmap(p8, trait, width=.15, colnames = F, color=NULL) +
scale_fill_viridis_c(option="D")
return(cirplot.trait)
}
library(ape) #utility fns
library(geiger) #utilty fns
library(OUwie)
library(fishtree)
library(dplyr)
library(tidyr)
continuous.data <- read.csv("D:/OneDrive - Pontificia Universidad Javeriana/Documents/NutritionalValuesFishes/Nutrients_EntireDataSet.csv")
tree <- fishtree_phylogeny(type="chronogram")
CleanData <- function(data, phylo) {
data$Species <- gsub(' ', '_' , continuous.data$Species)
data <- data %>%
group_by(Species) %>%
summarize(mean_Pr = mean(Pr)) %>%
drop_na()  %>%
filter(Species %in% phylo$tip.label)
trait <- as.numeric(data$mean_Pr)
names(trait) <- data$Species
datatree <- treedata(tree, trait)
return(datatree)
}
data <- CleanData(continuous.data, tree)
VisualizeData <- function(phy, data) {
phytools::contMap(phy, data)
}
#### This is how is fitted here
BM1 <- geiger::fitContinuous(data$phy, data$data, model="BM")
print(paste("The rate of evolution is", BM1$opt$sigsq, "in units of", "time"))
OU1 <- fitContinuous(data$phy, data$data, model="OU")
par(mfcol(c(1,2)))
plot(tree, show.tip.label=FALSE)
ou.tree <- rescale(tree, model="OU", OU1$opt$alpha)
plot(ou.tree)
AIC.BM1 <- AIC(BM1)
AIC.OU1 <- AIC(OU1)
delta.AIC.BM1 <- AIC.BM1 - min(AIC.BM1, AIC.OU1)
delta.AIC.OU1 <- AIC.OU1 - min(AIC.BM1, AIC.OU1)
##OUwie runs##
one.discrete.char <- as.numeric(data$data < mean(data$data))
reconstruction.info <- ace(one.discrete.char, data$phy, type="discrete", method="ML", CI=TRUE)
best.states <- colnames(reconstruction.info$lik.anc)[apply(reconstruction.info$lik.anc, 1, which.max)]
clean.df <- function(data, trait.name){
data.df <- as.data.frame(data)
data.df$Species <- rownames(data.df)
rownames(data.df) <- NULL
colnames(data.df) <- c(trait.name,"Species")
data.df[,trait.name] <- as.factor(data.df[, trait.name])
data.df <- data.df[,c("Species", trait.name)]
return(data.df)
}
cont.data <- data.frame(species=rownames(data$data), regime=best.states, trait=data$data[,1])
labeled.tree <- data$phy
labeled.tree$node.label <- best.states
nodeBased.OUMV <- OUwie(data$phy, cont.data, model="OUMV", simmap.tree=FALSE, diagn=FALSE)
print(nodeBased.OUMV)
models <- c("BM1","BMS","OU1","OUM","OUMV","OUMA","OUMVA")
results <- lapply(models, RunSingleOUwieModel, phy=tree, data=trait)
AICc.values<-sapply(results, "[[", "AICc")
names(AICc.values)<-models
AICc.values<-AICc.values-min(AICc.values)
print(AICc.values) #The best model is the one with smallest AICc score
best<-results[[which.min(AICc.values)]] #store for later
print(best) #prints info on best model
#### This is how is fitted here
BM1 <- geiger::fitContinuous(data$phy, data$data, model="BM")
data
data <- CleanData(continuous.data, tree)
continuous.data
continuous.data
continuous.data <- read.csv("D:/OneDrive - Pontificia Universidad Javeriana/Documents/NutritionalValuesFishes/Nutrients_EntireDataSet.csv")
continuous.data <- read.csv("D:/OneDrive - Pontificia Universidad Javeriana/Documents/NutritionalValuesFishes/Data/Nutrients_EntireDataSet.csv")
tree <- fishtree_phylogeny(type="chronogram")
CleanData <- function(data, phylo) {
data$Species <- gsub(' ', '_' , continuous.data$Species)
data <- data %>%
group_by(Species) %>%
summarize(mean_Pr = mean(Pr)) %>%
drop_na()  %>%
filter(Species %in% phylo$tip.label)
trait <- as.numeric(data$mean_Pr)
names(trait) <- data$Species
datatree <- treedata(tree, trait)
return(datatree)
}
data <- CleanData(continuous.data, tree)
data <- CleanData(continuous.data, tree)
VisualizeData <- function(phy, data) {
phytools::contMap(phy, data)
}
#### This is how is fitted here
BM1 <- geiger::fitContinuous(data$phy, data$data, model="BM")
print(paste("The rate of evolution is", BM1$opt$sigsq, "in units of", "time"))
OU1 <- fitContinuous(data$phy, data$data, model="OU")
par(mfcol(c(1,2)))
plot(tree, show.tip.label=FALSE)
ou.tree <- rescale(tree, model="OU", OU1$opt$alpha)
plot(ou.tree)
AIC.BM1 <- AIC(BM1)
AIC.OU1 <- AIC(OU1)
delta.AIC.BM1 <- AIC.BM1 - min(AIC.BM1, AIC.OU1)
delta.AIC.OU1 <- AIC.OU1 - min(AIC.BM1, AIC.OU1)
ou.tree
one.discrete.char <- as.numeric(data$data < mean(data$data))
reconstruction.info <- ace(one.discrete.char, data$phy, type="discrete", method="ML", CI=TRUE)
best.states <- colnames(reconstruction.info$lik.anc)[apply(reconstruction.info$lik.anc, 1, which.max)]
clean.df <- function(data, trait.name){
data.df <- as.data.frame(data)
data.df$Species <- rownames(data.df)
rownames(data.df) <- NULL
colnames(data.df) <- c(trait.name,"Species")
data.df[,trait.name] <- as.factor(data.df[, trait.name])
data.df <- data.df[,c("Species", trait.name)]
return(data.df)
}
cont.data <- data.frame(species=rownames(data$data), regime=best.states, trait=data$data[,1])
labeled.tree <- data$phy
labeled.tree$node.label <- best.states
nodeBased.OUMV <- OUwie(data$phy, cont.data, model="OUMV", simmap.tree=FALSE, diagn=FALSE)
print(nodeBased.OUMV)
models <- c("BM1","BMS","OU1","OUM","OUMV","OUMA","OUMVA")
results <- lapply(models, RunSingleOUwieModel, phy=tree, data=trait)
AICc.values<-sapply(results, "[[", "AICc")
names(AICc.values)<-models
AICc.values<-AICc.values-min(AICc.values)
print(AICc.values) #The best model is the one with smallest AICc score
best<-results[[which.min(AICc.values)]] #store for later
print(best) #prints info on best model
source("code/functions.R")
source("code/package.R")
continuous.data <- read.csv("D:/OneDrive - Pontificia Universidad Javeriana/Documents/NutritionalValuesFishes/Nutrients_EntireDataSet.csv")
tree <- fishtree_phylogeny(type="chronogram")
CleanData <- function(data, phylo) {
data$Species <- gsub(' ', '_' , continuous.data$Species)
data <- data %>%
group_by(Species) %>%
summarize(mean_Pr = mean(Pr)) %>%
drop_na()  %>%
filter(Species %in% phylo$tip.label)
trait <- as.numeric(data$mean_Pr)
names(trait) <- data$Species
datatree <- treedata(tree, trait)
return(datatree)
}
data <- CleanData(continuous.data, tree)
VisualizeData <- function(phy, data) {
phytools::contMap(phy, data)
}
#### This is how is fitted here
BM1 <- geiger::fitContinuous(data$phy, data$data, model="BM")
print(paste("The rate of evolution is", BM1$opt$sigsq, "in units of", "time"))
OU1 <- fitContinuous(data$phy, data$data, model="OU")
